import requests
import json
import logging
import re
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
import sqlite3
from urllib.parse import quote

logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    def __init__(self, db_path: str = "iot_devices.db"):
        self.db_path = db_path
        self.nvd_api_base = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.cve_cache = {}
        self._init_database()
    
    def _init_database(self):
        """Initialize vulnerability database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS cve_cache (
                cve_id TEXT PRIMARY KEY,
                data TEXT,
                last_updated TIMESTAMP
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS device_vulnerabilities (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                device_mac TEXT,
                cve_id TEXT,
                cvss_score REAL,
                severity TEXT,
                description TEXT,
                published_date TIMESTAMP,
                last_checked TIMESTAMP,
                FOREIGN KEY (device_mac) REFERENCES network_devices (mac_address)
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def scan_device_vulnerabilities(self, device_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        Comprehensive vulnerability scan for a device
        """
        try:
            vendor = device_info.get('manufacturer', '')
            device_type = device_info.get('device_type', '')
            firmware = device_info.get('firmware_version', '')
            model = device_info.get('device_model', '')
            
            cves = []
            
            # Search CVEs using multiple strategies
            search_terms = [
                f"{vendor} {device_type}",
                f"{vendor} {model}",
                f"{vendor} {device_type} {firmware}",
                f"{model} firmware",
                device_type
            ]
            
            for term in search_terms:
                if term.strip():
                    term_cves = self._search_nvd_cves(term)
                    cves.extend(term_cves)
            
            # Remove duplicates
            unique_cves = {cve['cve_id']: cve for cve in cves}.values()
            cves = list(unique_cves)
            
            # Calculate risk score based on vulnerabilities
            risk_score = self._calculate_vulnerability_risk(cves)
            
            # Check for common IoT vulnerabilities
            common_vulns = self._check_common_iot_vulnerabilities(device_info)
            cves.extend(common_vulns)
            
            return {
                'cves': cves,
                'total_cves': len(cves),
                'risk_score': risk_score,
                'critical_count': len([cve for cve in cves if cve.get('cvss_score', 0) >= 9.0]),
                'high_count': len([cve for cve in cves if 7.0 <= cve.get('cvss_score', 0) < 9.0]),
                'scan_timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Vulnerability scan failed for device {device_info.get('mac_address')}: {e}")
            return {
                'cves': [],
                'total_cves': 0,
                'risk_score': 0,
                'critical_count': 0,
                'high_count': 0,
                'scan_timestamp': datetime.now().isoformat()
            }
    
    def _search_nvd_cves(self, search_term: str) -> List[Dict[str, Any]]:
        """
        Search NVD database for CVEs
        """
        try:
            # Check cache first
            cache_key = search_term.lower()
            if cache_key in self.cve_cache:
                cached_data = self.cve_cache[cache_key]
                if datetime.now() - cached_data['timestamp'] < timedelta(hours=24):
                    return cached_data['cves']
            
            # Search NVD API
            url = f"{self.nvd_api_base}?keywordSearch={quote(search_term)}"
            headers = {
                'User-Agent': 'IoT-Security-Scanner/1.0',
                'Accept': 'application/json'
            }
            
            response = requests.get(url, headers=headers, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                cves = self._parse_nvd_response(data, search_term)
                
                # Cache the results
                self.cve_cache[cache_key] = {
                    'cves': cves,
                    'timestamp': datetime.now()
                }
                
                return cves
            else:
                logger.warning(f"NVD API returned status {response.status_code} for '{search_term}'")
                return []
                
        except Exception as e:
            logger.error(f"Error searching NVD for '{search_term}': {e}")
            return []
    
    def _parse_nvd_response(self, nvd_data: Dict, search_term: str) -> List[Dict[str, Any]]:
        """
        Parse NVD API response
        """
        cves = []
        
        if 'vulnerabilities' not in nvd_data:
            return cves
        
        for vuln in nvd_data['vulnerabilities']:
            cve_item = vuln.get('cve', {})
            cve_id = cve_item.get('id', '')
            
            # Get description
            descriptions = cve_item.get('descriptions', [])
            description = next((desc['value'] for desc in descriptions if desc['lang'] == 'en'), 'No description available')
            
            # Get CVSS score
            metrics = cve_item.get('metrics', {})
            cvss_score = 0.0
            severity = "UNKNOWN"
            
            if 'cvssMetricV31' in metrics:
                cvss_data = metrics['cvssMetricV31'][0]['cvssData']
                cvss_score = cvss_data.get('baseScore', 0.0)
            elif 'cvssMetricV2' in metrics:
                cvss_data = metrics['cvssMetricV2'][0]['cvssData']
                cvss_score = cvss_data.get('baseScore', 0.0)
            
            # Determine severity
            if cvss_score >= 9.0:
                severity = "CRITICAL"
            elif cvss_score >= 7.0:
                severity = "HIGH"
            elif cvss_score >= 4.0:
                severity = "MEDIUM"
            else:
                severity = "LOW"
            
            # Get published date
            published = cve_item.get('published', '')
            
            cves.append({
                'cve_id': cve_id,
                'description': description,
                'cvss_score': cvss_score,
                'severity': severity,
                'published': published,
                'search_term': search_term
            })
        
        return cves
    
    def _check_common_iot_vulnerabilities(self, device_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Check for common IoT-specific vulnerabilities
        """
        common_vulns = []
        
        # Check for default credentials
        if self._has_default_credentials_risk(device_info):
            common_vulns.append({
                'cve_id': 'IOT-DEFAULT-CREDENTIALS',
                'description': 'Device may have default credentials enabled',
                'cvss_score': 8.0,
                'severity': 'HIGH',
                'published': datetime.now().isoformat(),
                'search_term': 'default credentials'
            })
        
        # Check for unencrypted protocols
        protocols = device_info.get('protocols', [])
        if 'HTTP' in protocols and 'HTTPS' not in protocols:
            common_vulns.append({
                'cve_id': 'IOT-UNENCRYPTED-COMM',
                'description': 'Device uses unencrypted HTTP protocol',
                'cvss_score': 5.0,
                'severity': 'MEDIUM',
                'published': datetime.now().isoformat(),
                'search_term': 'unencrypted communication'
            })
        
        # Check for open ports with known vulnerabilities
        open_ports = device_info.get('open_ports', [])
        for port in open_ports:
            if port in [21, 23, 161]:  # FTP, Telnet, SNMP
                common_vulns.append({
                    'cve_id': f'IOT-OPEN-PORT-{port}',
                    'description': f'Device has port {port} open with known risks',
                    'cvss_score': 6.0,
                    'severity': 'MEDIUM',
                    'published': datetime.now().isoformat(),
                    'search_term': f'port {port} vulnerability'
                })
        
        return common_vulns
    
    def _has_default_credentials_risk(self, device_info: Dict[str, Any]) -> bool:
        """
        Check if device is known to have default credentials issues
        """
        manufacturer = device_info.get('manufacturer', '').lower()
        device_type = device_info.get('device_type', '').lower()
        
        risky_manufacturers = ['d-link', 'tp-link', 'netgear', 'linksys', 'tenda']
        risky_device_types = ['camera', 'router', 'sensor']
        
        return (any(brand in manufacturer for brand in risky_manufacturers) and
                any(dev_type in device_type for dev_type in risky_device_types))
    
    def _calculate_vulnerability_risk(self, cves: List[Dict[str, Any]]) -> int:
        """
        Calculate risk score based on CVEs
        """
        if not cves:
            return 0
        
        total_score = 0
        weight_factors = {
            'CRITICAL': 100,
            'HIGH': 75,
            'MEDIUM': 40,
            'LOW': 15
        }
        
        for cve in cves:
            severity = cve.get('severity', 'LOW')
            cvss_score = cve.get('cvss_score', 0)
            
            # Use CVSS score if available, otherwise use severity weight
            if cvss_score > 0:
                score = min(cvss_score * 10, 100)
            else:
                score = weight_factors.get(severity, 15)
            
            total_score += score
        
        # Normalize to 0-1000 scale
        risk_score = min(total_score * 2, 1000)
        return int(risk_score)
    
    def generate_google_dorks(self, device_info: Dict[str, Any]) -> List[str]:
        """
        Generate Google dorking queries for device reconnaissance
        """
        vendor = device_info.get('manufacturer', '')
        model = device_info.get('device_model', '')
        device_type = device_info.get('device_type', '')
        
        dorks = []
        
        # Vendor/model specific dorks
        if vendor and model:
            dorks.extend([
                f'inurl:/cgi-bin/ "{vendor}" "{model}"',
                f'intitle:"{vendor} {model}" "configuration"',
                f'intext:"{vendor} {model}" "password"',
                f'filetype:cfg "{vendor}" "{model}"'
            ])
        
        # Device type specific dorks
        if device_type:
            dorks.extend([
                f'inurl:"/viewer.html" "{device_type}"',
                f'intitle:"{device_type} Web Interface"',
                f'intext:"{device_type} Login" "admin"',
                f'site:pastebin.com "{device_type}" "password"'
            ])
        
        # General IoT dorks
        general_dorks = [
            'inurl:"/cgi-bin/" "IoT"',
            'intitle:"index of" "config" "IoT"',
            'filetype:xml "IoT" "configuration"',
            'intext:"default password" "IoT"'
        ]
        
        dorks.extend(general_dorks)
        return dorks
    
    def get_exploit_suggestions(self, cves: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Get exploit suggestions for CVEs
        """
        exploits = []
        
        for cve in cves:
            cve_id = cve.get('cve_id', '')
            severity = cve.get('severity', '')
            
            # This would integrate with ExploitDB or similar databases
            exploit_info = {
                'cve_id': cve_id,
                'severity': severity,
                'exploit_available': severity in ['CRITICAL', 'HIGH'],
                'suggested_actions': self._get_suggested_actions(cve)
            }
            
            exploits.append(exploit_info)
        
        return exploits
    
    def _get_suggested_actions(self, cve: Dict[str, Any]) -> List[str]:
        """
        Get suggested remediation actions for a CVE
        """
        actions = []
        severity = cve.get('severity', '')
        
        if severity in ['CRITICAL', 'HIGH']:
            actions.extend([
                "Apply security patches immediately",
                "Isolate device from critical network segments",
                "Monitor for suspicious activity"
            ])
        elif severity == 'MEDIUM':
            actions.extend([
                "Schedule firmware update",
                "Review device configuration",
                "Implement network segmentation"
            ])
        else:
            actions.extend([
                "Monitor for future updates",
                "Review during next maintenance window"
            ])
        
        return actions
    
    def save_device_vulnerabilities(self, device_mac: str, vulnerabilities: Dict[str, Any]):
        """
        Save vulnerability scan results to database
        """
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # Clear existing vulnerabilities for this device
            cursor.execute('DELETE FROM device_vulnerabilities WHERE device_mac = ?', (device_mac,))
            
            # Save new vulnerabilities
            for cve in vulnerabilities.get('cves', []):
                cursor.execute('''
                    INSERT INTO device_vulnerabilities 
                    (device_mac, cve_id, cvss_score, severity, description, published_date, last_checked)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                ''', (
                    device_mac,
                    cve.get('cve_id'),
                    cve.get('cvss_score', 0.0),
                    cve.get('severity', 'UNKNOWN'),
                    cve.get('description', ''),
                    cve.get('published', ''),
                    datetime.now().isoformat()
                ))
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            logger.error(f"Error saving vulnerabilities: {e}")